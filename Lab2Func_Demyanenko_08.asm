; ---------------------------------------------------------------------------- ;
;    Лабораторная работа №2 по курсу Программирование на языке ассемблера      ;
;    Вариант №8.                                                               ;
;    Выполнил студент Демьяненко И. Группа 344                                 ;
;                                                                              ;
;    Исходный модуль Lab2Func_Demyanenko_08.asm                                ;
;    Содержит реализованные функции в соответствии с заданием                  ;
; ---------------------------------------------------------------------------- ;
;    Задание:                                                                  ;
;        Реализовать операторы класса, представляющего собой четыре 32-битных  ;
;        целых со знаком с параллельной арифметикой насыщения с использованием ;
;        технологии SSE и без неё                                              ;

.DATA
ALIGN 16
bitmaskmin     oword 0FFFFFFFF80000000FFFFFFFF80000000h
bitmaskmax     oword 000000007FFFFFFF000000007FFFFFFFh
bitmasksse     oword 80000000800000008000000080000000h
antibitmasksse oword 7FFFFFFF7FFFFFFF7FFFFFFF7FFFFFFFh
bitmask        qword 8000000080000000h
antibitmask    qword 7FFFFFFF7FFFFFFFh
bitmask32      dword 80000000h
antibitmask32  dword 7FFFFFFFh

.CODE
; ---------------------------------------------------------------------------- ;
; Макропроцедура выполняет знаковое насыщение двойных слов, распакованных в    ;
; учетверённые и расположенных в a с использованием масок и b в качестве       ;
; вспомогательного регистра                                                    ;
; ---------------------------------------------------------------------------- ;
saturate2x32_sse MACRO a, b
    ; Проверить результат на переполнение вниз и выполнить насыщение
    movdqa xmm4, bitmaskmin ; Скопировать минимальное число
    pcmpgtq xmm4, a         ; Сравнить с минимальным числом
    movdqa b, xmm4          ; Обнулить переполненную часть
    pandn b, a        
    pand xmm4, bitmasksse   ; Выставить переполненную часть в минимум
    por b, xmm4

    ; Проверить результат на переполнение вверх и выполнить насыщение
    movdqa xmm4, b            ; Скопировать результат
    pcmpgtq xmm4, bitmaskmax  ; Сравнить с максимальным числом
    movdqa a, xmm4            ; Обнулить переполненную часть
    pandn a, b         
    pand xmm4, antibitmasksse ; Выставить переполненную часть в максимум
    por a, xmm4
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет сумму четырёх пар знаковых 32-разрядных слагаемых a и b с          ;
; использованием технологии SSE и записывает результат в sum                   ;
; void add4x32_sse(__int32* sum, __int32* a, __int32* b)                       ;
; ---------------------------------------------------------------------------- ;
add4x32_sse PROC ; RCX - *sum
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm и расширить знаком до 64битных
    movdqa xmm4, [rdx]       ; Загрузить 128 бит разом
    pmovsxdq xmm0, xmm4      ; Переместить и расширить знаком первые два операнда
    pshufd xmm4, xmm4, 1110b ; Переместить вторые два операнда на младшие позиции
    pmovsxdq xmm2, xmm4      ; Переместить и расширить знаком вторые два операнда
    movdqa xmm4, [r8]
    pmovsxdq xmm1, xmm4
    pshufd xmm4, xmm4, 1110b
    pmovsxdq xmm3, xmm4
    
    ; Выполнить сложение как учетверённых слов
    paddq xmm0, xmm1
    paddq xmm2, xmm3

    
    ; Проверить результат на переполнение вниз и выполнить насыщение
    movdqa xmm4, bitmaskmin ; Скопировать минимальное число
    pcmpgtq xmm4, xmm0         ; Сравнить с минимальным числом
    movdqa xmm1, xmm4          ; Обнулить переполненную часть
    pandn xmm1, xmm0        
    pand xmm4, bitmasksse   ; Выставить переполненную часть в минимум
    por xmm1, xmm4

    ; Проверить результат на переполнение вверх и выполнить насыщение
    movdqa xmm4, xmm1            ; Скопировать результат
    pcmpgtq xmm4, bitmaskmax  ; Сравнить с максимальным числом
    movdqa xmm0, xmm4            ; Обнулить переполненную часть
    pandn xmm0, xmm1         
    pand xmm4, antibitmasksse ; Выставить переполненную часть в максимум
    por xmm0, xmm4

    ; Выполнить насыщение
    saturate2x32_sse xmm0, xmm1
    saturate2x32_sse xmm2, xmm3

    ; Приготовить результаты к записи в память
    pshufd xmm4, xmm0, 00001000b
    pshufd xmm2, xmm2, 00001000b
    pextrq rax, xmm2, 0
    pinsrq xmm4, rax, 1

    ; Записать результат в память
    movdqa [rcx], xmm4

    ret
add4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет разность четырёх пар знаковых 32-разрядных слагаемых a и b с       ;
; использованием технологии SSE и записывает результат в diff                  ;
; void sub4x32_sse(__int32* diff, __int32* a, __int32* b)                      ;
; ---------------------------------------------------------------------------- ;
sub4x32_sse PROC ; RCX - *diff
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm и расширить знаком до 64битных
    movdqa xmm4, [rdx]       ; Загрузить 128 бит разом
    pmovsxdq xmm0, xmm4      ; Переместить и расширить знаком первые два операнда
    pshufd xmm4, xmm4, 1110b ; Переместить вторые два операнда на младшие позиции
    pmovsxdq xmm2, xmm4      ; Переместить и расширить знаком вторые два операнда
    movdqa xmm4, [r8]
    pmovsxdq xmm1, xmm4
    pshufd xmm4, xmm4, 1110b
    pmovsxdq xmm3, xmm4

    ; Выполнить вычитание как учетверённых слов
    psubq xmm0, xmm1
    psubq xmm2, xmm3

    ; Выполнить насыщение
    saturate2x32_sse xmm0, xmm1
    saturate2x32_sse xmm2, xmm3

    ; Приготовить результаты к записи в память
    pshufd xmm4, xmm0, 00001000b
    pshufd xmm2, xmm2, 00001000b
    pextrq rax, xmm2, 0
    pinsrq xmm4, rax, 1

    ; Записать результат в память
    movdqa [rcx], xmm4

    ret
sub4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет произведение четырёх пар знаковых 32-разрядных множителей a и b с  ;
; использованием технологии SSE и записывает результат в diff                  ;
; void mul4x32_sse(__int32* prod, __int32* a, __int32* b)                      ;
; ---------------------------------------------------------------------------- ;
mul4x32_sse PROC ; RCX - *prod
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm и расширить знаком до 64битных
    movdqa xmm4, [rdx]       ; Загрузить 128 бит разом
    pmovsxdq xmm0, xmm4      ; Переместить и расширить знаком первые два операнда
    pshufd xmm4, xmm4, 1110b ; Переместить вторые два операнда на младшие позиции
    pmovsxdq xmm2, xmm4      ; Переместить и расширить знаком вторые два операнда
    movdqa xmm4, [r8]
    pmovsxdq xmm1, xmm4
    pshufd xmm4, xmm4, 1110b
    pmovsxdq xmm3, xmm4

    ; Выполнить умножение
    pmuldq xmm0, xmm1
    pmuldq xmm2, xmm3

    ; Выполнить насыщение
    saturate2x32_sse xmm0, xmm1
    saturate2x32_sse xmm2, xmm3

    ; Приготовить результаты к записи в память
    pshufd xmm4, xmm0, 00001000b
    pshufd xmm2, xmm2, 00001000b
    pextrq rax, xmm2, 0
    pinsrq xmm4, rax, 1

    ; Записать результат в память
    movdqa [rcx], xmm4

    ret
mul4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет частное четырёх пар знаковых 32-разрядных чисел a и b с            ;
; использованием технологии SSE и записывает результат в diff                  ;
; void div4x32_sse(__int32* quot, __int32* a, __int32* b)                      ;
; ---------------------------------------------------------------------------- ;
div4x32_sse PROC ; RCX - *quot
                 ; RDX - *a
                 ; R8  - *b
    
    ; Загрузить все операнды в регистры xmm с преобразованием в double
    movdqa xmm4, [rdx]       ; Загрузить 128 бит разом
    cvtdq2pd xmm0, xmm4      ; Переместить первые два операнда с преобразованием в double
    pshufd xmm4, xmm4, 1110b ; Переставить вторые два операнда в младшие позиции
    cvtdq2pd xmm2, xmm4      ; Переместить вторые два операнда с преобразованием в double
    movdqa xmm4, [r8]        ; Загрузить 128 бит разом
    cvtdq2pd xmm1, xmm4      ; Переместить первые два операнда с преобразованием в double
    pshufd xmm4, xmm4, 1110b ; Переставить вторые два операнда в младшие позиции
    cvtdq2pd xmm3, xmm4      ; Переместить вторые два операнда с преобразованием в double

    ; Выполнить деление
    divpd xmm0, xmm1
    divpd xmm2, xmm3

    ; Преобразовать частное обратно в dword и приготовить к записи в память
    cvtpd2dq xmm4, xmm0
    cvtpd2dq xmm2, xmm2
    pextrq rax, xmm2, 0
    pinsrq xmm4, rax, 1

    ; Записать результат в память
    movdqa [rcx], xmm4

    ret
div4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет остаток от деления четырёх пар знаковых 32-разрядных чисел a и b с ;
; использованием технологии SSE и записывает результат в rem                   ;
; void mod4x32_sse(__int32* rem, __int32* a, __int32* b)                       ;
; ---------------------------------------------------------------------------- ;
mod4x32_sse PROC ; RCX - *rem
                 ; RDX - *a
                 ; R8  - *b

    ; Сохранить xmm6 без использования памяти
    pextrq r9, xmm6, 0
    pextrq r10, xmm6, 0

    ; Загрузить все операнды из памяти, дублировать и преобразовать в double
	movdqa xmm0, [rdx]       ; Загрузить 128 бит разом
	movdqa xmm6, xmm0        ; Сохранить для последующего вычитания
	cvtdq2pd xmm2, xmm0      ; Преобразовать в double
	pshufd xmm0, xmm0, 1110b ; Переместить старшую часть в младшую
	cvtdq2pd xmm3, xmm0      ; Преобразовать в double
	movdqa xmm1, [r8]
	movdqa xmm5, xmm1
	cvtdq2pd xmm4, xmm1
	pshufd xmm1, xmm1, 1110b
	cvtdq2pd xmm0, xmm1
	
    ; Выполнить деление
	divpd xmm2, xmm4
	divpd xmm3, xmm0

    ; Преобразовать частные в dword и переместить в xmm0
	cvttpd2dq xmm0, xmm3
	pshufd xmm0, xmm0, 01000100b
	cvttpd2dq xmm1, xmm2
	pblendw xmm0, xmm1, 00001111b

    ; Домножить частное на делитель и вычесть из делимого
	movdqa xmm2, xmm0
	pmuldq xmm2, xmm5
	pshufd xmm0, xmm0, 11110101b
	pshufd xmm5, xmm5, 11110101b
    pmuldq xmm0, xmm5
	pshufd xmm0, xmm0, 10100000b
	pblendw xmm2, xmm0, 11001100b
	psubd xmm6, xmm2

    ; Записать результат в память
	movdqa [rcx], xmm6

    ; Восстановить xmm6
    pinsrq xmm6, r9, 0
    pinsrq xmm6, r10, 1

    ret
mod4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет сумму двух пар знаковых 32-разрядных слагаемых      ;
; a и b и записывает результат в sum                                           ;
; ---------------------------------------------------------------------------- ;
add2x32 MACRO a, b, sum
    ; Сложить без учёта знака
    mov rax, a
    and rax, antibitmask
    mov r13, b
    and r13, antibitmask
    add rax, r13

    ; Знак первого операнда
    mov r9, a
    and r9, bitmask

    ; Знак второго операнда
    mov r10, b
    and r10, bitmask

    ; Проверить на переполнение в положительную сторону ('+' + '+' = '-')
    mov r11, r9
    not r11
    mov r13, r10
    not r13
    and r11, r13
    and r11, rax
    and r11, bitmask ; Старший бит составляющей r11 – индикатор переполнения
                     ; этой составляющей

    ; Вычислить маску переполнения 
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена нулями. Если нет, то единицами.
    
    ; Применить маску переполнения
    and rax, r12
    
    ; Заменить переполненную часть суммы на 01...1
    not r12
    xor r12, r11
    or  rax, r12

    ; Проверить на переполнение в отрицательную сторону ('-' + '-' = '+')
    mov r11, rax
    not r11
    and r11, r9
    and r11, r10 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена нулями. Если нет, то единицами.

    ; Применить маску переполнения
    and rax, r12

    ; Заменить переполненную часть суммы на 10...0
    ; (совпадает с маской переполнения)
    or  rax, r11

    ; Восстановить знак составляющей суммы, если операнды были разных знаков
    xor rax, r9
    xor rax, r10

    ; Записать результат
    mov sum, rax
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет сумму четырёх пар знаковых 32-разрядных слагаемых a и b и          ;
; записывает результат в sum                                                   ;
; void add4x32(__int32* sum, __int32* a, __int32* b)                           ;
; ---------------------------------------------------------------------------- ;
add4x32 PROC ; RCX - *sum
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15

    mov r14, [rdx]
    mov r15, [r8]
    add2x32 r14, r15, r14 ; Параллельное сложение первых двух операндов
    mov [rcx], r14

    mov r14, [rdx+8]
    mov r15, [r8+8]
    add2x32 r14, r15, r14 ; Параллельное сложение вторых двух операндов
    mov [rcx+8], r14

    pop r15
    pop r14
    pop r13
    pop r12

    ret
add4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет разность двух пар знаковых 32-разрядных слагаемых   ;
; a и b и записывает результат в diff                                          ;
; ---------------------------------------------------------------------------- ;
sub2x32 MACRO a, b, diff
    ; Вычесть с защитой от заёма
    mov rax, a
    or  rax, bitmask
    mov r13, b
    and r13, antibitmask
    sub rax, r13
    xor rax, bitmask

    ; Знак первого операнда
    mov r9, a
    and r9, bitmask

    ; Знак второго операнда
    mov r10, b
    and r10, bitmask

    ; Восстановить знак суммы
    xor rax, r9
    xor rax, r10

    ; Проверить на переполнение в положительную сторону ('+' - '-' = '-')
    mov r11, r9
    not r11
    and r11, r10
    and r11, rax ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13 ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.

    ; Заменить переполненную вверх составляющую на 01...1
    or  rax, r12
    xor rax, r11

    ; Проверить на переполнение в отрицательную сторону ('-' - '+' = '+')
    mov r11, r9
    mov r13, r10
    not r13
    and r11, r13
    mov r13, rax
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.
    
    ; Заменить переполненную вниз составляющую на 10...0
    and rax, r12
    or rax, r11

    ; Записать результат
    mov diff, rax
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет разность четырёх пар знаковых 32-разрядных слагаемых a и b и       ;
; записывает результат в diff                                                  ;
; void sub4x32(__int32* diff, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
sub4x32 PROC ; RCX - *diff
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15

    mov r14, [rdx]
    mov r15, [r8]
    sub2x32 r14, r15, r14 ; Параллельное вычитание первых двух операндов
    mov [rcx], r14

    mov r14, [rdx+8]
    mov r15, [r8+8]
    sub2x32 r14, r15, r14 ; Параллельное вычитание вторых двух операндов
    mov [rcx+8], r14

    pop r15
    pop r14
    pop r13
    pop r12

    ret
sub4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет произведение двух знаковых 32-разрядных множителей  ;
; eax и b и записывает результат в eax                                         ;
; ---------------------------------------------------------------------------- ;
mul1x32 MACRO b
    ; Перемножить eax и b с расширением на edx
    imul b

    ; Проверить наличие старшей части
    setc r14b

    ; Преобразовать знак старшей части произведения
    ; в максимальное или минимальное число
    ; 0... -> 01...1
    ; 1... -> 10...0
    sar edx, 31
    xor edx, antibitmask32

    ; Если было переполнение, выполнить насыщение eax
    cmp r14b, 1
    cmovz eax, edx
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет произведение четырёх пар знаковых 32-разрядных множителей a и b и  ;
; записывает результат в prod                                                  ;
; void mul4x32(__int32* prod, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
mul4x32 PROC ; RCX - *prod
             ; RDX - *a
             ; R8  - *b
    push r12
    
    mov r9, [rdx]
    mov r10, [r8]
    mov r11, rdx ; rdx неизбежно изменится при умножении

    ; Записать произведение первых двух операндов в младшую половину r12
    mov eax, r9d
    mul1x32 r10d
    mov r12d, eax

    ; Записать произведение вторых двух операндов в старшую половину r12
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    mul1x32 r10d
    shl rax, 32
    or  r12, rax

    mov [rcx], r12

    mov r9, [r11+8]
    mov r10, [r8+8]
    
    ; Записать произведение третьих двух операндов в младшую половину r13
    mov eax, r9d
    mul1x32 r10d
    mov r12d, eax

    ; Записать произведение четвёртых двух операндов в старшую половину r13
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    mul1x32 r10d
    shl rax, 32
    or  r12, rax

    mov [rcx+8], r12

    pop r12

    ret
mul4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет частное четырёх пар знаковых 32-разрядных чисел a и b и            ;
; записывает результат в quot                                                  ;
; void div4x32(__int32* quot, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
div4x32 PROC ; RCX - *quot
             ; RDX - *a
             ; R8  - *b
    push r12

    mov r9, [rdx]
    mov r10, [r8]
    mov r11, rdx ; rdx неизбежно изменится при подготовке к делению
        
    ; Записать частное первых двух операндов в младшую половину r12
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, eax

    ; Записать частное вторых двух операндов в старшую половину r12
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rax, 32
    or  r12, rax
    
    mov [rcx], r12

    mov r9, [r11+8]
    mov r10, [r8+8]

    ; Записать частное третьих двух операндов в младшую половину r13
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, eax

    ; Записать частное четвёртых двух операндов в старшую половину r13
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rax, 32
    or  r12, rax

    mov [rcx+8], r12

    pop r12

    ret
div4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет остаток от деления четырёх пар знаковых 32-разрядных чисел a и b и ;
; записывает результат в rem                                                   ;
; void mod4x32(__int32* rem, __int32* a, __int32* b)                           ;
; ---------------------------------------------------------------------------- ;
mod4x32 PROC ; RCX - *rem
             ; RDX - *a
             ; R8  - *b
    push r12

    mov r9, [rdx]
    mov r10, [r8]
    mov r11, rdx ; rdx неизбежно изменится при подготовке к делению
        
    ; Записать остаток от деления первых двух операндов в младшую половину r12
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, edx

    ; Записать остаток от деления вторых двух операндов в старшую половину r12
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rdx, 32
    or  r12, rdx
    
    mov [rcx], r12

    mov r9, [r11+8]
    mov r10, [r8+8]

    ; Записать остаток от деления третьих двух операндов в младшую половину r13
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, edx

    ; Записать остаток от деления четвёртых двух операндов в старшую половину r13
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rdx, 32
    or  r12, rdx

    mov [rcx+8], r12

    pop r12

    ret
mod4x32 ENDP
END
