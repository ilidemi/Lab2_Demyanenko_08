; ---------------------------------------------------------------------------- ;
;    Лабораторная работа №2 по курсу Программирование на языке ассемблера      ;
;    Вариант №8.                                                               ;
;    Выполнил студент Демьяненко И. Группа 344                                 ;
;                                                                              ;
;    Исходный модуль Lab2Func_Demyanenko_08.asm                                ;
;    Содержит реализованные функции в соответствии с заданием                  ;
; ---------------------------------------------------------------------------- ;
;    Задание:                                                                  ;
;        Реализовать операторы класса, представляющего собой четыре 32-битных  ;
;        целых со знаком с параллельной арифметикой насыщения с использованием ;
;        технологии SSE и без неё                                              ;

.DATA
ALIGN 16
bitmaskmin    qword 0FFFFFFFF80000000h
bitmaskmax    qword 000000007FFFFFFFh
bitmask       qword 8000000080000000h
antibitmask   qword 7FFFFFFF7FFFFFFFh
bitmask32     dword 80000000h
antibitmask32 dword 7FFFFFFFh

.CODE
; ---------------------------------------------------------------------------- ;
; Макропроцедура заполняет регистры xmm2, xmm3, xmm4 и xmm5 масками            ;
; bitmaskmin, bitmaskmax, bitmask и antibitmask соответственно                 ;
; ---------------------------------------------------------------------------- ;
fillmasks_sse MACRO
    ; Заполнить xmm2 минимальными 32битными числами
    mov r9, bitmaskmin
    pinsrq xmm2, r9, 0
    pinsrq xmm2, r9, 1

    ; Заполнить xmm3 максимальными 32битными числами
    mov r9, bitmaskmax
    pinsrq xmm3, r9, 0
    pinsrq xmm3, r9, 1

    ; Заполнить xmm4 32битной маской знака
    mov r9, bitmask
    pinsrq xmm4, r9, 0
    pinsrq xmm4, r9, 1

    ; Заполнить xmm5 32битной маской знака
    mov r9, antibitmask
    pinsrq xmm5, r9, 0
    pinsrq xmm5, r9, 1    
ENDM

; ---------------------------------------------------------------------------- ;
; Макропроцедура выполняет знаковое насыщение двойных слов, распакованных в    ;
; учетверённые и расположенных в a с использованием масок и b в качестве       ;
; вспомогательного регистра                                                    ;
; ---------------------------------------------------------------------------- ;
saturate2x32_sse MACRO a, b
    ; Проверить результат на переполнение вниз и выполнить насыщение
    movdqa xmm6, xmm2 ; Скопировать минимальное число
    pcmpgtq xmm6, a   ; Сравнить с минимальным числом
    movdqa b, xmm6    ; Обнулить переполненную часть
    pandn b, a        
    pand xmm6, xmm4   ; Выставить переполненную часть в минимум
    por b, xmm6

    ; Проверить результат на переполнение вверх и выполнить насыщение
    movdqa xmm6, b     ; Скопировать результат
    pcmpgtq xmm6, xmm3 ; Сравнить с максимальным числом
    movdqa a, xmm6     ; Обнулить переполненную часть
    pandn a, b         
    pand xmm6, xmm5    ; Выставить переполненную часть в максимум
    por a, xmm6
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет сумму четырёх пар знаковых 32-разрядных слагаемых a и b с          ;
; использованием технологии SSE и записывает результат в sum                   ;
; void add4x32_sse(__int32* sum, __int32* a, __int32* b)                       ;
; ---------------------------------------------------------------------------- ;
add4x32_sse PROC ; RCX - *sum
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm и расширить знаком до 64битных
    movq xmm0, qword ptr [rdx]
    pmovsxdq xmm0, xmm0
    movq xmm1, qword ptr [r8]
    pmovsxdq xmm1, xmm1
    movq xmm8, qword ptr [rdx+8]
    pmovsxdq xmm8, xmm8
    movq xmm9, qword ptr [r8+8]
    pmovsxdq xmm9, xmm9

    ; Выполнить сложение как учетверённых слов
    paddq xmm0, xmm1
    paddq xmm8, xmm9

    ; Инициализировать маски
    fillmasks_sse

    ; Выполнить насыщение
    saturate2x32_sse xmm0, xmm1
    saturate2x32_sse xmm8, xmm9

    ; Расположить результаты в младшей части регистров
    pshufd xmm0, xmm0, 8
    pshufd xmm8, xmm8, 8

    ; Записать результат в память
    movq qword ptr [rcx], xmm0
    movq qword ptr [rcx+8], xmm8

    ret
add4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет разность четырёх пар знаковых 32-разрядных слагаемых a и b с       ;
; использованием технологии SSE и записывает результат в diff                  ;
; void sub4x32_sse(__int32* diff, __int32* a, __int32* b)                      ;
; ---------------------------------------------------------------------------- ;
sub4x32_sse PROC ; RCX - *diff
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm и расширить знаком до 64битных
    movq xmm0, qword ptr [rdx]
    pmovsxdq xmm0, xmm0
    movq xmm1, qword ptr [r8]
    pmovsxdq xmm1, xmm1
    movq xmm8, qword ptr [rdx+8]
    pmovsxdq xmm8, xmm8
    movq xmm9, qword ptr [r8+8]
    pmovsxdq xmm9, xmm9

    ; Выполнить вычитание как учетверённых слов
    psubq xmm0, xmm1
    psubq xmm8, xmm9

    ; Инициализировать маски
    fillmasks_sse

    ; Выполнить насыщение
    saturate2x32_sse xmm0, xmm1
    saturate2x32_sse xmm8, xmm9

    ; Расположить результаты в младшей части регистров
    pshufd xmm0, xmm0, 8
    pshufd xmm8, xmm8, 8

    ; Записать результат в память
    movq qword ptr [rcx], xmm0
    movq qword ptr [rcx+8], xmm8

    ret
sub4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет произведение четырёх пар знаковых 32-разрядных множителей a и b с  ;
; использованием технологии SSE и записывает результат в diff                  ;
; void mul4x32_sse(__int32* prod, __int32* a, __int32* b)                      ;
; ---------------------------------------------------------------------------- ;
mul4x32_sse PROC ; RCX - *prod
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm и расширить знаком до 64битных
    movq xmm0, qword ptr [rdx]
    pmovsxdq xmm0, xmm0
    movq xmm1, qword ptr [r8]
    pmovsxdq xmm1, xmm1
    movq xmm8, qword ptr [rdx+8]
    pmovsxdq xmm8, xmm8
    movq xmm9, qword ptr [r8+8]
    pmovsxdq xmm9, xmm9

    ; Выполнить умножение
    pmuldq xmm0, xmm1
    pmuldq xmm8, xmm9

    ; Инициализировать маски
    fillmasks_sse

    ; Выполнить насыщение
    saturate2x32_sse xmm0, xmm1
    saturate2x32_sse xmm8, xmm9

    ; Расположить результаты в младшей части регистров
    pshufd xmm0, xmm0, 8
    pshufd xmm8, xmm8, 8

    ; Записать результат в память
    movq qword ptr [rcx], xmm0
    movq qword ptr [rcx+8], xmm8

    ret
mul4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет частное четырёх пар знаковых 32-разрядных чисел a и b с            ;
; использованием технологии SSE и записывает результат в diff                  ;
; void div4x32_sse(__int32* quot, __int32* a, __int32* b)                      ;
; ---------------------------------------------------------------------------- ;
div4x32_sse PROC ; RCX - *quot
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm с преобразованием в double
    cvtpi2pd xmm0, qword ptr [rdx]
    cvtpi2pd xmm1, qword ptr [r8]
    cvtpi2pd xmm8, qword ptr [rdx+8]
    cvtpi2pd xmm9, qword ptr [r8+8]

    ; Выполнить деление
    divpd xmm0, xmm1
    divpd xmm8, xmm9

    ; Преобразовать частное обратно в dword
    cvtpd2dq xmm0, xmm0
    cvtpd2dq xmm8, xmm8

    ; Записать результат в память
    movq qword ptr [rcx], xmm0
    movq qword ptr [rcx+8], xmm8

    ret
div4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет остаток от деления четырёх пар знаковых 32-разрядных чисел a и b с ;
; использованием технологии SSE и записывает результат в rem                   ;
; void mod4x32_sse(__int32* rem, __int32* a, __int32* b)                       ;
; ---------------------------------------------------------------------------- ;
mod4x32_sse PROC ; RCX - *rem
                 ; RDX - *a
                 ; R8  - *b

    ; Загрузить все операнды в регистры xmm с преобразованием в double
    cvtpi2pd xmm0, qword ptr [rdx]
    mov r9, [r8]
    movq mm0, r9
    cvtpi2pd xmm1, mm0
    cvtpi2pd xmm8, qword ptr [rdx+8]
    mov r10, [r8+8]
    movq mm0, r10
    cvtpi2pd xmm9, mm0

    ; Выполнить деление
    divpd xmm0, xmm1
    divpd xmm8, xmm9

    ; Преобразовать частное обратно в dword
    cvtpd2dq xmm0, xmm0
    cvtpd2dq xmm8, xmm8
    
    ; Расширить до qword
    pmovsxdq xmm0, xmm0
    pmovsxdq xmm8, xmm8

    ; Загрузить делители в регистры xmm 
    pinsrd xmm1, r9d, 0
    pinsrd xmm9, r10d, 0
    shr r9, 32
    shr r10, 32
    pinsrd xmm1, r9d, 2
    pinsrd xmm9, r10d, 2

    

    ; Записать результат в память
    movq qword ptr [rcx], xmm0
    movq qword ptr [rcx+8], xmm8

    ret
rem4x32_sse ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет сумму двух пар знаковых 32-разрядных слагаемых      ;
; a и b и записывает результат в sum                                           ;
; ---------------------------------------------------------------------------- ;
add2x32 MACRO a, b, sum
    ; Сложить без учёта знака
    mov rax, a
    and rax, antibitmask
    mov r13, b
    and r13, antibitmask
    add rax, r13

    ; Знак первого операнда
    mov r9, a
    and r9, bitmask

    ; Знак второго операнда
    mov r10, b
    and r10, bitmask

    ; Проверить на переполнение в положительную сторону ('+' + '+' = '-')
    mov r11, r9
    not r11
    mov r13, r10
    not r13
    and r11, r13
    and r11, rax
    and r11, bitmask ; Старший бит составляющей r11 – индикатор переполнения
                     ; этой составляющей

    ; Вычислить маску переполнения 
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена нулями. Если нет, то единицами.
    
    ; Применить маску переполнения
    and rax, r12
    
    ; Заменить переполненную часть суммы на 01...1
    not r12
    xor r12, r11
    or  rax, r12

    ; Проверить на переполнение в отрицательную сторону ('-' + '-' = '+')
    mov r11, rax
    not r11
    and r11, r9
    and r11, r10 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена нулями. Если нет, то единицами.

    ; Применить маску переполнения
    and rax, r12

    ; Заменить переполненную часть суммы на 10...0
    ; (совпадает с маской переполнения)
    or  rax, r11

    ; Восстановить знак составляющей суммы, если операнды были разных знаков
    xor rax, r9
    xor rax, r10

    ; Записать результат
    mov sum, rax
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет сумму четырёх пар знаковых 32-разрядных слагаемых a и b и          ;
; записывает результат в sum                                                   ;
; void add4x32(__int32* sum, __int32* a, __int32* b)                           ;
; ---------------------------------------------------------------------------- ;
add4x32 PROC ; RCX - *sum
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15

    mov r14, [rdx]
    mov r15, [r8]
    add2x32 r14, r15, r14 ; Параллельное сложение первых двух операндов
    mov [rcx], r14

    mov r14, [rdx+8]
    mov r15, [r8+8]
    add2x32 r14, r15, r14 ; Параллельное сложение вторых двух операндов
    mov [rcx+8], r14

    pop r15
    pop r14
    pop r13
    pop r12

    ret
add4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет разность двух пар знаковых 32-разрядных слагаемых   ;
; a и b и записывает результат в diff                                          ;
; ---------------------------------------------------------------------------- ;
sub2x32 MACRO a, b, diff
    ; Вычесть с защитой от заёма
    mov rax, a
    or  rax, bitmask
    mov r13, b
    and r13, antibitmask
    sub rax, r13
    xor rax, bitmask

    ; Знак первого операнда
    mov r9, a
    and r9, bitmask

    ; Знак второго операнда
    mov r10, b
    and r10, bitmask

    ; Восстановить знак суммы
    xor rax, r9
    xor rax, r10

    ; Проверить на переполнение в положительную сторону ('+' - '-' = '-')
    mov r11, r9
    not r11
    and r11, r10
    and r11, rax ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13 ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.

    ; Заменить переполненную вверх составляющую на 01...1
    or  rax, r12
    xor rax, r11

    ; Проверить на переполнение в отрицательную сторону ('-' - '+' = '+')
    mov r11, r9
    mov r13, r10
    not r13
    and r11, r13
    mov r13, rax
    not r13
    and r11, r13 ; Старший бит составляющей r11 – индикатор переполнения
                 ; этой составляющей в rax

    ; Вычислить маску переполнения
    mov r12, r11
    shl r12, 1
    mov r13, r11
    shr r13, 31
    sub r12, r13
    not r12      ; Если составляющая суммы переполнилась, то соответствующая
                 ; ей часть маски заполнена единицами. Если нет, то нулями.
    
    ; Заменить переполненную вниз составляющую на 10...0
    and rax, r12
    or rax, r11

    ; Записать результат
    mov diff, rax
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет разность четырёх пар знаковых 32-разрядных слагаемых a и b и       ;
; записывает результат в diff                                                  ;
; void sub4x32(__int32* diff, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
sub4x32 PROC ; RCX - *diff
             ; RDX - *a
             ; R8  - *b
    push r12
    push r13
    push r14
    push r15

    mov r14, [rdx]
    mov r15, [r8]
    sub2x32 r14, r15, r14 ; Параллельное вычитание первых двух операндов
    mov [rcx], r14

    mov r14, [rdx+8]
    mov r15, [r8+8]
    sub2x32 r14, r15, r14 ; Параллельное вычитание вторых двух операндов
    mov [rcx+8], r14

    pop r15
    pop r14
    pop r13
    pop r12

    ret
sub4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Макропроцедура вычисляет произведение двух знаковых 32-разрядных множителей  ;
; eax и b и записывает результат в eax                                         ;
; ---------------------------------------------------------------------------- ;
mul1x32 MACRO b
    ; Перемножить eax и b с расширением на edx
    imul b

    ; Проверить наличие старшей части
    setc r14b

    ; Преобразовать знак старшей части произведения
    ; в максимальное или минимальное число
    ; 0... -> 01...1
    ; 1... -> 10...0
    sar edx, 31
    xor edx, antibitmask32

    ; Если было переполнение, выполнить насыщение eax
    cmp r14b, 1
    cmovz eax, edx
ENDM

; ---------------------------------------------------------------------------- ;
; Вычисляет произведение четырёх пар знаковых 32-разрядных множителей a и b и  ;
; записывает результат в prod                                                  ;
; void mul4x32(__int32* prod, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
mul4x32 PROC ; RCX - *prod
             ; RDX - *a
             ; R8  - *b
    push r12
    
    mov r9, [rdx]
    mov r10, [r8]
    mov r11, rdx ; rdx неизбежно изменится при умножении

    ; Записать произведение первых двух операндов в младшую половину r12
    mov eax, r9d
    mul1x32 r10d
    mov r12d, eax

    ; Записать произведение вторых двух операндов в старшую половину r12
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    mul1x32 r10d
    shl rax, 32
    or  r12, rax

    mov [rcx], r12

    mov r9, [r11+8]
    mov r10, [r8+8]
    
    ; Записать произведение третьих двух операндов в младшую половину r13
    mov eax, r9d
    mul1x32 r10d
    mov r12d, eax

    ; Записать произведение четвёртых двух операндов в старшую половину r13
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    mul1x32 r10d
    shl rax, 32
    or  r12, rax

    mov [rcx+8], r12

    pop r12

    ret
mul4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет частное четырёх пар знаковых 32-разрядных чисел a и b и            ;
; записывает результат в quot                                                  ;
; void div4x32(__int32* quot, __int32* a, __int32* b)                          ;
; ---------------------------------------------------------------------------- ;
div4x32 PROC ; RCX - *quot
             ; RDX - *a
             ; R8  - *b
    push r12

    mov r9, [rdx]
    mov r10, [r8]
    mov r11, rdx ; rdx неизбежно изменится при подготовке к делению
        
    ; Записать частное первых двух операндов в младшую половину r12
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, eax

    ; Записать частное вторых двух операндов в старшую половину r12
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rax, 32
    or  r12, rax
    
    mov [rcx], r12

    mov r9, [r11+8]
    mov r10, [r8+8]

    ; Записать частное третьих двух операндов в младшую половину r13
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, eax

    ; Записать частное четвёртых двух операндов в старшую половину r13
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rax, 32
    or  r12, rax

    mov [rcx+8], r12

    pop r12

    ret
div4x32 ENDP

; ---------------------------------------------------------------------------- ;
; Вычисляет остаток от деления четырёх пар знаковых 32-разрядных чисел a и b и ;
; записывает результат в rem                                                   ;
; void mod4x32(__int32* rem, __int32* a, __int32* b)                           ;
; ---------------------------------------------------------------------------- ;
mod4x32 PROC ; RCX - *rem
             ; RDX - *a
             ; R8  - *b
    push r12

    mov r9, [rdx]
    mov r10, [r8]
    mov r11, rdx ; rdx неизбежно изменится при подготовке к делению
        
    ; Записать остаток от деления первых двух операндов в младшую половину r12
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, edx

    ; Записать остаток от деления вторых двух операндов в старшую половину r12
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rdx, 32
    or  r12, rdx
    
    mov [rcx], r12

    mov r9, [r11+8]
    mov r10, [r8+8]

    ; Записать остаток от деления третьих двух операндов в младшую половину r13
    mov eax, r9d
    cdq
    idiv r10d
    mov r12d, edx

    ; Записать остаток от деления четвёртых двух операндов в старшую половину r13
    shr r9, 32
    shr r10, 32
    mov eax, r9d
    cdq
    idiv r10d
    shl rdx, 32
    or  r12, rdx

    mov [rcx+8], r12

    pop r12

    ret
mod4x32 ENDP
END
